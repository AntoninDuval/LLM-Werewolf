from player.base_player import Player
from typing import Callable, List
from random import choice
from loguru import logger

NAMES = [
    "John",
    "Alice",
    "Bob",
    "Charlie",
    "David",
    "Eve",
    "Frank",
    "Grace",
    "Hannah",
    "Ivan",
    "Julia",
    "Kevin",
    "Laura",
    "Michael",
    "Nina",
    "Oscar",
    "Paul",
    "Quentin",
    "Rachel",
    "Steve",
    "Tina",
    "Ursula",
    "Victor",
    "Wendy",
    "Xavier",
    "Yvonne",
    "Zack",
    "Olivia",
    "Peter",
    "Sophie",
    "Tom",
    "Emily",
    "Harry",
    "Lucas",
    "Mia",
    "Oliver",
    "Sophia",
    "William",
    "Ava",
    "Noah",
    "Isabella",
    "James",
    "Charlotte",
    "Benjamin",
    "Amelia",
    "Ethan",
    "Ella",
    "Alexander",
    "Grace",
    "Henry",
]


class LLMPlayer(Player):
    def __init__(self, name, role, llm_handler: Callable[[str], str], strategy=None, personality=None):
        """
        LLMPlayer constructor.

        Args:
            name (str): Name of the player.
            role (str): Role of the player (e.g., "Werewolf", "Villager").
            llm_handler (Callable[[str], str]): A function that takes a prompt and returns a response from the LLM.
        """
        super().__init__(name, role)
        self.llm_handler = llm_handler
        self.name = choice(NAMES)
        self.strategy = strategy
        self.personality = personality

    def get_message_player(self, state_summary: dict) -> str:
        """
        Generate a message from the LLM based on the game state.

        Args:
            state_summary (dict): Summary of the current game state.

        Returns:
            str: Message generated by the LLM.
        """

        if state_summary["current_phase"] == "Day Debate":
            prompt_template = open("./src/llm/prompts/debate_phase.txt", "r").read()
        elif state_summary["current_phase"] == "Werewolf Meeting":
            prompt_template = open("./src/llm/prompts/werewolf_meeting.txt", "r").read()
        else:
            # Stop the function if the current phase is not recognized
            return ""

        state_summary["formatted_chat_history"] = self.format_chat_history(
            state_summary["chat_history"]
        )
        state_summary["player_name"] = self.name
        state_summary["player_role"] = self.role
        state_summary['allies'] = self.allies
        state_summary["strategy"] = self.strategy
        state_summary["personality_traits"] = self.personality["personality_traits"]
        state_summary["answer_strategy"] = self.personality["answer_strategy"]

        output = self.llm_handler.generate_response(
            prompt_template=prompt_template, variables=state_summary
        )
        if output == "WAITING":

            # logger.info(f'Player {self.name} decided to pass')
            return ""
        else:
            return output

    def format_chat_history(self, chat_history):
        return "\n".join(
            [
                f"Day {entry['day']} ({entry['phase']} Phase) - {entry['sender']}: {entry['text']}"
                for entry in chat_history
            ]
        )

    def vote(self, choices: List[Player], state_summary: dict) -> Player:
        """
        Decide whom to vote for using the LLM.

        Args:
            choices (List[Player]): List of players to vote for.
            state_summary (dict): Summary of the current game state.

        Returns:
            Player: The player chosen to vote for.
        """
        if state_summary["current_phase"] == "Day Execution":
            prompt_template = open("./src/llm/prompts/voting_phase.txt", "r").read()
        elif state_summary["current_phase"] == "Werewolf Vote":
            prompt_template = open("./src/llm/prompts/werewolf_vote.txt", "r").read()
        else:
            logger.error("Invalid phase for voting")

        state_summary["formatted_chat_history"] = self.format_chat_history(
            state_summary["chat_history"]
        )
        state_summary["player_name"] = self.name
        state_summary["player_role"] = self.role
        state_summary["choices"] = [
            f"{digit} - {player_name}" for digit, player_name in enumerate(choices)
        ]
        state_summary['allies'] = self.allies
        state_summary["personality_traits"] = self.personality["personality_traits"]
        state_summary["answer_strategy"] = self.personality["answer_strategy"]

        output = -1
        while type(output) != int:
            try:
                output = self.llm_handler.generate_response(
                    prompt_template=prompt_template, variables=state_summary
                )
                output = int(output)
            except ValueError:
                logger.error("Invalid vote choice")
            
        return choices[int(output)]

    def last_words(self, state_summary: dict) -> str:
        """
        Generate last words for the player.

        Args:
            state_summary (dict): Summary of the current game state.

        Returns:
            str: Last words generated by the LLM.
        """
        prompt_template = open("./src/llm/prompts/last_words.txt", "r").read()
        state_summary["formatted_chat_history"] = self.format_chat_history(
            state_summary["chat_history"]
        )
        state_summary["player_name"] = self.name
        state_summary["player_role"] = self.role
        state_summary['allies'] = self.allies
        state_summary["personality_traits"] = self.personality["personality_traits"]
        state_summary["answer_strategy"] = self.personality["answer_strategy"]

        output = self.llm_handler.generate_response(
            prompt_template=prompt_template, variables=state_summary
        )
        return output